# -*- coding: utf-8 -*-
"""Solar_Panel_Performance_Forecasting_dataset.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YVnjfyk8sUsrxOyjVVJo30rIDkP9KtdP
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression, LogisticRegression
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import mean_squared_error, r2_score, classification_report, accuracy_score, confusion_matrix
import warnings
warnings.filterwarnings('ignore')

# Set style for better-looking plots
plt.style.use('seaborn-v0_8')
sns.set_palette("husl")

# ============================================================================
# SUMMER SEASON DATA GENERATION
# ============================================================================
print("Generating Summer Season Data...")

feature_ranges = {
    'summer': {
        'irradiance': (600, 1000),
        'humidity': (10, 50),
        'wind_speed': (0, 5),
        'ambient_temperature': (30, 45),
        'tilt_angle': (10, 40),
    }
}

# Summer months with exact days
summer_months_days = {
    'March': 31,
    'April': 30,
    'May': 31,
    'June': 30
}

def calc_kwh_summer(irradiance, humidity, wind_speed, ambient_temp, tilt_angle):
    return (0.25 * irradiance
            - 0.05 * humidity
            + 0.02 * wind_speed
            + 0.1 * ambient_temp
            - 0.03 * abs(tilt_angle - 30))

def generate_summer_data_by_month(feature_ranges, months_days):
    data = []
    for month, days in months_days.items():
        for _ in range(days):
            irr = np.random.uniform(*feature_ranges['summer']['irradiance'])
            hum = np.random.uniform(*feature_ranges['summer']['humidity'])
            wind = np.random.uniform(*feature_ranges['summer']['wind_speed'])
            temp = np.random.uniform(*feature_ranges['summer']['ambient_temperature'])
            tilt = np.random.uniform(*feature_ranges['summer']['tilt_angle'])
            kwh = calc_kwh_summer(irr, hum, wind, temp, tilt)
            data.append({
                'irradiance': round(irr, 2),
                'humidity': round(hum, 2),
                'wind_speed': round(wind, 2),
                'ambient_temperature': round(temp, 2),
                'tilt_angle': round(tilt, 2),
                'kwh': round(kwh, 2),
                'season': 'summer',
                'month': month
            })
    return pd.DataFrame(data)

# Generate summer data matching days in each month
df_summer = generate_summer_data_by_month(feature_ranges, summer_months_days)
print(df_summer.head())
print(f'Total summer data points generated: {len(df_summer)}')  # Should be 31+30+31+30=122

# ============================================================================
# WINTER SEASON DATA GENERATION
# ============================================================================
print("\nGenerating Winter Season Data...")

feature_ranges['winter'] = {
    'irradiance': (300, 700),
    'humidity': (30, 70),
    'wind_speed': (1, 6),
    'ambient_temperature': (5, 20),
    'tilt_angle': (10, 40),
}

# Winter months with exact days
winter_months_days = {
    'November': 30,
    'December': 31,
    'January': 31,
    'February': 28  # Not considering leap year here; can be adjusted if needed
}

def calc_kwh_winter(irradiance, humidity, wind_speed, ambient_temp, tilt_angle):
    return (0.18 * irradiance
            - 0.03 * humidity
            + 0.015 * wind_speed
            + 0.08 * ambient_temp
            - 0.02 * abs(tilt_angle - 30))

def generate_winter_data_by_month(feature_ranges, months_days):
    data = []
    for month, days in months_days.items():
        for _ in range(days):
            irr = np.random.uniform(*feature_ranges['winter']['irradiance'])
            hum = np.random.uniform(*feature_ranges['winter']['humidity'])
            wind = np.random.uniform(*feature_ranges['winter']['wind_speed'])
            temp = np.random.uniform(*feature_ranges['winter']['ambient_temperature'])
            tilt = np.random.uniform(*feature_ranges['winter']['tilt_angle'])
            kwh = calc_kwh_winter(irr, hum, wind, temp, tilt)
            data.append({
                'irradiance': round(irr, 2),
                'humidity': round(hum, 2),
                'wind_speed': round(wind, 2),
                'ambient_temperature': round(temp, 2),
                'tilt_angle': round(tilt, 2),
                'kwh': round(kwh, 2),
                'season': 'winter',
                'month': month
            })
    return pd.DataFrame(data)

# Generate winter data matching days in each month
df_winter = generate_winter_data_by_month(feature_ranges, winter_months_days)
print(df_winter.head())
print(f'Total winter data points generated: {len(df_winter)}')  # Should be 30+31+31+28=120

# ============================================================================
# MONSOON SEASON DATA GENERATION
# ============================================================================
print("\nGenerating Monsoon Season Data...")

feature_ranges['monsoon'] = {
    'irradiance': (100, 600),
    'humidity': (70, 100),
    'wind_speed': (2, 8),
    'ambient_temperature': (20, 35),
    'tilt_angle': (10, 40),
}

# Monsoon months with exact days
monsoon_months_days = {
    'July': 31,
    'August': 31,
    'September': 30,
    'October': 31
}

def calc_kwh_monsoon(irradiance, humidity, wind_speed, ambient_temp, tilt_angle):
    return (0.15 * irradiance
            - 0.1 * humidity
            + 0.01 * wind_speed
            + 0.05 * ambient_temp
            - 0.04 * abs(tilt_angle - 30))

def generate_monsoon_data_by_month(feature_ranges, months_days):
    data = []
    for month, days in months_days.items():
        for _ in range(days):
            irr = np.random.uniform(*feature_ranges['monsoon']['irradiance'])
            hum = np.random.uniform(*feature_ranges['monsoon']['humidity'])
            wind = np.random.uniform(*feature_ranges['monsoon']['wind_speed'])
            temp = np.random.uniform(*feature_ranges['monsoon']['ambient_temperature'])
            tilt = np.random.uniform(*feature_ranges['monsoon']['tilt_angle'])
            kwh = calc_kwh_monsoon(irr, hum, wind, temp, tilt)
            data.append({
                'irradiance': round(irr, 2),
                'humidity': round(hum, 2),
                'wind_speed': round(wind, 2),
                'ambient_temperature': round(temp, 2),
                'tilt_angle': round(tilt, 2),
                'kwh': round(kwh, 2),
                'season': 'monsoon',
                'month': month
            })
    return pd.DataFrame(data)

# Generate monsoon data matching days in each month
df_monsoon = generate_monsoon_data_by_month(feature_ranges, monsoon_months_days)
print(df_monsoon.head())
print(f'Total monsoon data points generated: {len(df_monsoon)}')  # Should be 31+31+30+31=123

# ============================================================================
# COMBINE ALL SEASONS AND SAVE TO CSV
# ============================================================================
print("\nCombining all seasons and saving to CSV...")

# Concatenate summer, winter, and monsoon dataframes
df_all_seasons = pd.concat([df_summer, df_winter, df_monsoon], ignore_index=True)

# Show first few rows to verify
print(df_all_seasons.head())

# Print dataset info
print("\nDataset Info:")
df_all_seasons.info()

# Save to CSV (same as your original code)
df_all_seasons.to_csv('solar_performance_all_seasons.csv', index=False)
print(f"\nCSV file saved: solar_performance_all_seasons.csv")
print(f"Total data points: {len(df_all_seasons)}")

# ============================================================================
# ENHANCED VISUALIZATIONS (KEEPING THE GRAPHS I PROVIDED)
# ============================================================================

# 1. Comprehensive Dashboard with Multiple Subplots
fig, axes = plt.subplots(2, 3, figsize=(18, 12))
fig.suptitle('Solar Panel Performance Analysis Dashboard', fontsize=16, fontweight='bold')

# 1a. Enhanced violin plot for kWh distribution by season
sns.violinplot(data=df_all_seasons, x='season', y='kwh', ax=axes[0,0])
axes[0,0].set_title('Energy Output Distribution by Season')
axes[0,0].set_xlabel('Season')
axes[0,0].set_ylabel('Energy Output (kWh)')

# 1b. Monthly average kWh with error bars
monthly_stats = df_all_seasons.groupby('month')['kwh'].agg(['mean', 'std']).reset_index()
month_order = ['January', 'February', 'March', 'April', 'May', 'June', 
               'July', 'August', 'September', 'October', 'November', 'December']
monthly_stats['month'] = pd.Categorical(monthly_stats['month'], categories=month_order, ordered=True)
monthly_stats = monthly_stats.sort_values('month')

axes[0,1].errorbar(range(len(monthly_stats)), monthly_stats['mean'], 
                   yerr=monthly_stats['std'], marker='o', capsize=5, linewidth=2)
axes[0,1].set_xticks(range(len(monthly_stats)))
axes[0,1].set_xticklabels(monthly_stats['month'], rotation=45)
axes[0,1].set_title('Monthly Average Energy Output')
axes[0,1].set_ylabel('Energy Output (kWh)')
axes[0,1].grid(True, alpha=0.3)

# 1c. Feature correlation heatmap
correlation_matrix = df_all_seasons[['irradiance', 'humidity', 'wind_speed', 
                                   'ambient_temperature', 'tilt_angle', 'kwh']].corr()
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', center=0, 
            square=True, ax=axes[0,2])
axes[0,2].set_title('Feature Correlation Matrix')

# 1d. Irradiance vs kWh scatter plot with season colors
sns.scatterplot(data=df_all_seasons, x='irradiance', y='kwh', hue='season', 
                alpha=0.6, ax=axes[1,0])
axes[1,0].set_title('Irradiance vs Energy Output')
axes[1,0].set_xlabel('Irradiance')
axes[1,0].set_ylabel('Energy Output (kWh)')

# 1e. Temperature vs kWh by season
sns.boxplot(data=df_all_seasons, x='season', y='ambient_temperature', ax=axes[1,1])
axes[1,1].set_title('Temperature Distribution by Season')
axes[1,1].set_xlabel('Season')
axes[1,1].set_ylabel('Temperature (°C)')

# 1f. Wind speed and humidity relationship
sns.scatterplot(data=df_all_seasons, x='wind_speed', y='humidity', 
                hue='season', size='kwh', alpha=0.6, ax=axes[1,2])
axes[1,2].set_title('Wind Speed vs Humidity (sized by kWh)')
axes[1,2].set_xlabel('Wind Speed')
axes[1,2].set_ylabel('Humidity (%)')

plt.tight_layout()
plt.show()

# 2. Interactive-style Time Series with Rolling Averages
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(15, 10))

# Add day number for time series
df_all_seasons['day_number'] = range(len(df_all_seasons))

# 2a. Daily kWh with 7-day rolling average
ax1.plot(df_all_seasons['day_number'], df_all_seasons['kwh'], 
         alpha=0.3, color='lightblue', label='Daily kWh')
ax1.plot(df_all_seasons['day_number'], 
         df_all_seasons['kwh'].rolling(window=7, center=True).mean(), 
         color='darkblue', linewidth=2, label='7-day Rolling Average')

# Add seasonal backgrounds
seasons_info = df_all_seasons.groupby('season')['day_number'].agg(['min', 'max'])
colors = {'summer': 'yellow', 'winter': 'lightcyan', 'monsoon': 'lightgreen'}
for season, (min_day, max_day) in seasons_info.iterrows():
    ax1.axvspan(min_day, max_day, alpha=0.2, color=colors[season], label=f'{season.title()} Season')

ax1.set_title('Daily Solar Energy Output with Seasonal Patterns', fontsize=14, fontweight='bold')
ax1.set_xlabel('Day Number')
ax1.set_ylabel('Energy Output (kWh)')
ax1.legend()
ax1.grid(True, alpha=0.3)

# 2b. Cumulative energy production
ax2.plot(df_all_seasons['day_number'], df_all_seasons['kwh'].cumsum(), 
         color='green', linewidth=2)
ax2.set_title('Cumulative Energy Production', fontsize=14, fontweight='bold')
ax2.set_xlabel('Day Number')
ax2.set_ylabel('Cumulative Energy (kWh)')
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# 3. Advanced Feature Analysis
fig, axes = plt.subplots(2, 2, figsize=(15, 10))
fig.suptitle('Advanced Feature Analysis', fontsize=16, fontweight='bold')

# 3a. Pair plot style - multiple features vs kWh
features = ['irradiance', 'humidity', 'wind_speed', 'ambient_temperature']
for i, feature in enumerate(features):
    ax = axes[i//2, i%2]
    for season in df_all_seasons['season'].unique():
        season_data = df_all_seasons[df_all_seasons['season'] == season]
        ax.scatter(season_data[feature], season_data['kwh'], 
                  label=season, alpha=0.6, s=20)
    
    # Add trend line
    z = np.polyfit(df_all_seasons[feature], df_all_seasons['kwh'], 1)
    p = np.poly1d(z)
    ax.plot(df_all_seasons[feature], p(df_all_seasons[feature]), 
            "r--", alpha=0.8, linewidth=2)
    
    ax.set_xlabel(feature.replace('_', ' ').title())
    ax.set_ylabel('Energy Output (kWh)')
    ax.set_title(f'{feature.replace("_", " ").title()} vs Energy Output')
    ax.legend()
    ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# ============================================================================
# MACHINE LEARNING MODELS (SAME AS YOUR ORIGINAL CODE)
# ============================================================================

# Load the CSV (same as your original approach)
df = pd.read_csv('solar_performance_all_seasons.csv')

# LINEAR REGRESSION MODEL
print("\n" + "="*60)
print("LINEAR REGRESSION MODEL")
print("="*60)

# Define features (X) and target (y)
X = df[['irradiance', 'humidity', 'wind_speed', 'ambient_temperature', 'tilt_angle']]
y = df['kwh']

# Split the dataset
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
print(f"Training set size: {X_train.shape}")
print(f"Test set size: {X_test.shape}")

# Train the model
model = LinearRegression()
model.fit(X_train, y_train)

# Make predictions
y_pred = model.predict(X_test)

# Evaluate the model
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print("Model Coefficients:", model.coef_)
print("Intercept:", model.intercept_)
print("Mean Squared Error (MSE):", mse)
print("R² Score:", r2)

# 4. IMPROVED MODEL VISUALIZATION
fig, axes = plt.subplots(1, 3, figsize=(18, 6))
fig.suptitle('Linear Regression Model Analysis', fontsize=16, fontweight='bold')

# 4a. Improved Actual vs Predicted
axes[0].scatter(y_test, y_pred, alpha=0.6, color='steelblue', s=50)
axes[0].plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 
             'r--', lw=2, label='Perfect Prediction')
axes[0].set_xlabel('Actual kWh')
axes[0].set_ylabel('Predicted kWh')
axes[0].set_title('Actual vs Predicted Energy Output')
axes[0].legend()
axes[0].grid(True, alpha=0.3)

# Add R² score as text
axes[0].text(0.05, 0.95, f'R² = {r2:.3f}', transform=axes[0].transAxes, 
             bbox=dict(boxstyle="round,pad=0.3", facecolor="yellow", alpha=0.7))

# 4b. Residuals plot
residuals = y_test - y_pred
axes[1].scatter(y_pred, residuals, alpha=0.6, color='coral')
axes[1].axhline(y=0, color='black', linestyle='--', alpha=0.8)
axes[1].set_xlabel('Predicted kWh')
axes[1].set_ylabel('Residuals')
axes[1].set_title('Residuals Plot')
axes[1].grid(True, alpha=0.3)

# 4c. Feature importance (coefficients)
feature_names = ['Irradiance', 'Humidity', 'Wind Speed', 'Temperature', 'Tilt Angle']
coefficients = model.coef_
colors = ['green' if coef > 0 else 'red' for coef in coefficients]
bars = axes[2].bar(feature_names, coefficients, color=colors, alpha=0.7)
axes[2].set_xlabel('Features')
axes[2].set_ylabel('Coefficient Value')
axes[2].set_title('Feature Importance (Coefficients)')
axes[2].tick_params(axis='x', rotation=45)
axes[2].grid(True, alpha=0.3)

# Add value labels on bars
for bar, coef in zip(bars, coefficients):
    height = bar.get_height()
    axes[2].text(bar.get_x() + bar.get_width()/2., height,
                f'{coef:.3f}', ha='center', va='bottom' if height > 0 else 'top')

plt.tight_layout()
plt.show()

# LOGISTIC REGRESSION MODEL
print("\n" + "="*60)
print("LOGISTIC REGRESSION MODEL (SEASON CLASSIFICATION)")
print("="*60)

# Define features (X) and target (y) - including kwh as feature
X_class = df[['irradiance', 'humidity', 'wind_speed', 'ambient_temperature', 'tilt_angle', 'kwh']]
y_class = df['season']

# Encode the categorical target
le = LabelEncoder()
y_encoded = le.fit_transform(y_class)

# Split into train and test
X_train_class, X_test_class, y_train_class, y_test_class = train_test_split(
    X_class, y_encoded, test_size=0.2, random_state=42)
print(f"Training set size: {X_train_class.shape}")
print(f"Test set size: {X_test_class.shape}")

# Train model
model_class = LogisticRegression(max_iter=1000)
model_class.fit(X_train_class, y_train_class)

# Make predictions
y_pred_class = model_class.predict(X_test_class)

# Evaluate
print("Accuracy:", accuracy_score(y_test_class, y_pred_class))
print("\nClassification Report:\n", classification_report(y_test_class, y_pred_class, target_names=le.classes_))

# 5. ENHANCED CLASSIFICATION VISUALIZATION
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))
fig.suptitle('Season Classification Analysis', fontsize=16, fontweight='bold')

# 5a. Improved confusion matrix
cm = confusion_matrix(y_test_class, y_pred_class)
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', 
            xticklabels=le.classes_, yticklabels=le.classes_,
            ax=ax1, cbar_kws={'label': 'Count'})
ax1.set_xlabel('Predicted Season')
ax1.set_ylabel('Actual Season')
ax1.set_title('Confusion Matrix')

# 5b. Classification accuracy by season
accuracy_by_season = []
for i, season in enumerate(le.classes_):
    season_mask = y_test_class == i
    season_accuracy = (y_pred_class[season_mask] == y_test_class[season_mask]).mean()
    accuracy_by_season.append(season_accuracy)

bars = ax2.bar(le.classes_, accuracy_by_season, color=['orange', 'lightblue', 'lightgreen'])
ax2.set_xlabel('Season')
ax2.set_ylabel('Accuracy')
ax2.set_title('Classification Accuracy by Season')
ax2.set_ylim(0, 1)

# Add percentage labels on bars
for bar, acc in zip(bars, accuracy_by_season):
    height = bar.get_height()
    ax2.text(bar.get_x() + bar.get_width()/2., height,
             f'{acc:.1%}', ha='center', va='bottom')

plt.tight_layout()
plt.show()

# Final Summary
print("\n" + "="*60)
print("MODEL PERFORMANCE SUMMARY")
print("="*60)
print(f"Linear Regression R² Score: {r2_score(y_test, y_pred):.4f}")
print(f"Linear Regression RMSE: {np.sqrt(mean_squared_error(y_test, y_pred)):.4f}")
print(f"Classification Accuracy: {accuracy_score(y_test_class, y_pred_class):.4f}")
print("="*60)